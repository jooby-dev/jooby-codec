/* eslint-disable @typescript-eslint/no-unsafe-member-access */
import * as Message from '../../src/analog/message.js';
import * as uplinkCommands from '../../src/analog/commands/uplink/index.js';
import DataSegmentsCollector from '../../src/analog/DataSegmentsCollector.js';
import {MTXLORA} from '../../src/analog/constants/hardwareTypes.js';
import {UPLINK} from '../../src/constants/directions.js';
import permutations from '../../src/utils/permutations.js';
import getHexFromBytes from '../../src/utils/getHexFromBytes.js';
import getBytesFromHex from '../../src/utils/getBytesFromHex.js';


const expectedMtxBuffer = `
    4d1010796430280fff011d00000008001a00000008001d00000008011d00000008001a000000
    08001d00000008011d00000008001a00000008001d00000008011d00000008001a0000000800
    1d00000008013a00000008013a00000008013a00000008013a000000080000
`;

const messages = [
    '1e28c4314d1010796430280fff011d00000008001a00000008001d00000008011d00000008001a00000033',
    '1e28c43208001d00000008011d00000008001a00000008001d00000008011d00000008001a00000008009d',
    '1e21c4b31d00000008013a00000008013a00000008013a00000008013a00000008000063d0b9e5e7'
];

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const expectedCommands = {
    LastEvent: {
        sequenceNumber: 208,
        status: {
            isLockedOut: true,
            isMagneticInfluence: false,
            isMeterCaseOpen: true,
            isMeterFailure: true,
            isMeterProgramRestarted: true,
            isMeterTerminalBoxOpen: false,
            isModuleCompartmentOpen: true,
            isNewTariffPlanReceived: false,
            isParametersSetLocally: true,
            isParametersSetRemotely: false,
            isTariffPlanChanged: false,
            isTimeCorrected: true,
            isTimeSet: false
        }
    }
};

const checkMessages = ( sequence: Array<string> ) => {
    const collector = new DataSegmentsCollector();
    const commands: Record<string, object | null> = {};
    let actualMtxBuffer = '';

    for ( const hex of sequence ) {
        const message = Message.fromHex(hex, {direction: UPLINK, hardwareType: MTXLORA});

        expect(message.isValid).toBe(true);

        for ( const {command} of message.commands ) {
            if ( command instanceof uplinkCommands.DataSegment ) {
                actualMtxBuffer += getHexFromBytes(collector.push(command.parameters), {separator: ''});
            } else {
                commands[command.constructor.name] = command.parameters || null;
            }
        }
    }

    expect(expectedCommands).toStrictEqual(commands);
    expect(getBytesFromHex(actualMtxBuffer)).toStrictEqual(getBytesFromHex(expectedMtxBuffer));
};


describe('valid sequences', () => {
    permutations<string>(messages).forEach((sequence, index) => {
        test(`test case #${index}`, () => {
            checkMessages(sequence);
        });
    });
});
